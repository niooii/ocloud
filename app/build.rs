use std::env;
use std::fs;
use std::path::Path;
use syn::{visit::Visit, ItemStruct};

struct WsEventCollector {
    events: Vec<String>,
}

impl<'ast> Visit<'ast> for WsEventCollector {
    fn visit_item_struct(&mut self, node: &'ast ItemStruct) {
        // Look for #[ocloud_macros::WsIncomingEvent] attribute
        for attr in &node.attrs {
            if let Ok(meta) = attr.meta.require_path_only() {
                if meta.is_ident("WsIncomingEvent") {
                    self.events.push(node.ident.to_string());
                    break;
                }
            }
            // Also check for the full path
            if attr.path().segments.len() == 2
                && attr.path().segments[0].ident == "ocloud_macros" 
                    && attr.path().segments[1].ident == "WsIncomingEvent" {
                    self.events.push(node.ident.to_string());
                    break;
                }
        }
        syn::visit::visit_item_struct(self, node);
    }
}

fn main() {
    let mut collector = WsEventCollector { events: Vec::new() };
    
    // Scan all .rs files in src/
    scan_directory("src", &mut collector);
    
    // Generate the enum code
    let enum_code = generate_ws_enum_code(&collector.events);
    
    // Write to OUT_DIR
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("ws_events.rs");
    fs::write(&dest_path, enum_code).unwrap();
    
    println!("cargo:rerun-if-changed=src/");
    println!("Generated WebSocket events enum with {} variants", collector.events.len());
}

fn scan_directory(dir: &str, collector: &mut WsEventCollector) {
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                if let Some(path_str) = path.to_str() {
                    scan_directory(path_str, collector);
                }
            } else if path.extension().is_some_and(|ext| ext == "rs") {
                if let Ok(content) = fs::read_to_string(&path) {
                    if let Ok(file) = syn::parse_file(&content) {
                        collector.visit_file(&file);
                    }
                }
            }
        }
    }
}

fn generate_ws_enum_code(events: &[String]) -> String {
    if events.is_empty() {
        return String::from(
            r#"
            // No WebSocket events found - generating empty enum
            #[derive(Debug, Clone)]
            pub enum WsIncomingEventType {}
            "#
        );
    }
    
    let variants_code: Vec<String> = events.iter()
        .map(|name| format!("    {name}({name}),"))
        .collect();
    
    let variant_names = events.iter()
        .map(|name| format!("\"{name}\""))
        .collect::<Vec<_>>()
        .join(", ");
    
    format!(
        r#"
        // AUTO-GENERATED WebSocket Events Enum
        // This file is generated by build.rs - do not edit manually!

        #[derive(Debug, Clone, serde::Deserialize)]
        #[serde(tag = "t", content = "d")]
        #[enum_dispatch::enum_dispatch(WsIncomingEvent)]
        pub enum WsIncomingEventType {{
        {}
        }}

        impl WsIncomingEventType {{
            /// Returns the names of all registered WebSocket event types
            pub fn all_event_types() -> &'static [&'static str] {{
                &[{}]
            }}
            
            /// Returns the number of registered event types
            pub fn event_count() -> usize {{
                {}
            }}
        }}
        "#,
        variants_code.join("\n"),
        variant_names,
        events.len()
    )
}